#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <windows.h>
#include <time.h>
#define ECB 1
#include "lib/aes-min.h"

// CRC32 determined using Ghidra
uint32_t crc32(int32_t namelen, uint8_t *buffer) {

  if (namelen <= 0) {
    return 0;
  }

  uint32_t result = 0;
  for (int i = 0; i < namelen; i++) {
    int bitcount = 8;
    result ^= (buffer[i] ^ 0xffffffff);

    do {
      uint32_t calc = -(result & 1) & 0xedb88320;
      result = result >> 1 ^ calc;
      bitcount--;
    } while (bitcount != 0);

    result ^= 0xffffffff;
  }
  return result;
}

void init() { 
    srand(time(NULL));
}

struct keydata_format {
  uint32_t checksum;
  uint16_t feature_flags;
  uint16_t magic;
  uint32_t serial;
  uint32_t random;
};

void process_serial(char *name, char *serial_out) {
  uint8_t aes_ctx[AES128_KEY_SCHEDULE_SIZE];
  uint32_t crc = crc32(lstrlen(name), name);
  // generated by a C runtime RNG with seed 0x12345678
  uint8_t aes_key[0x10] = {0xE9, 0x3F, 0x0D, 0xA1, 0x96, 0x95, 0x31, 0x04,
                           0x49, 0x2D, 0x9E, 0x61, 0x83, 0xCF, 0x09, 0x6F};
  uint8_t key_buffer[AES_BLOCK_SIZE] = {0};
  uint8_t encrypted_buffer[AES_BLOCK_SIZE] = {0};
  
  struct keydata_format *key = (struct keydata_format *)key_buffer;
  key->checksum = crc;
  key->feature_flags = 0xFFFF;
  key->magic = 0x1979;
  key->random = 0;
  key->serial = rand();

  aes128_key_schedule(aes_ctx, aes_key);

 while (1) {
    memcpy(encrypted_buffer, key_buffer, 0x10);
    aes128_encrypt(encrypted_buffer, aes_ctx);
    key->random++;
    if (key->random == 0)
      key->serial++;
    uint32_t hash = 0;
    for (uint8_t i = 0; i < 12; i++)
      hash += encrypted_buffer[i];
    if ((encrypted_buffer[0x0E] == (hash >> 8)) && (encrypted_buffer[0x0F] == LOBYTE(hash)))
      break;
  };

  uint8_t buffer_str[33];
  for (uint8_t i = 0; i < 16; ++i)
    sprintf(&buffer_str[i * 2], "%02X", (uint8_t)encrypted_buffer[i]);

  sprintf(serial_out, "N=%s K=%s", name, buffer_str);
}
